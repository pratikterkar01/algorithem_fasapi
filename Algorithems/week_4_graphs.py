# -*- coding: utf-8 -*-
"""Week_4_Graphs.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12OIiXjeaolEeLeg8GZWmNMnowP3E7614
"""

import  torch
import numpy as np
from collections import deque

## Non Linear data structure Graphspytho
## mainly graphs represented as the adjecency list and adjecency matrix
## see the adjecency matrix
class AdjecencyMatrix:
  def __init__(self,mat = None):
    self.mat = mat
    self.i = None
    self.j = None
  def addEdge(self,i,j):
    self.mat[i][j] = 1
    self.mat[j][i] = 1

  def displayMatrix(self):
     for row in mat:
        print(" ".join(map(str, row)))

mat = np.zeros((4,4))
matrix = AdjecencyMatrix(mat)
matrix.addEdge(0,1)
matrix.addEdge(0,2)
matrix.addEdge(2,3)
matrix.displayMatrix()

## Adjecency list  using nested list
class AdjecencyList:
  def __init__(self,adj):
    self.adj = adj

  def addEdge(self,i,j):
    self.adj[i].append(j)
    self.adj[j].append(i)

  def displayList(self):
    for i in range(len(self.adj)):
        print(f"{i}: ", end="")
        for j in self.adj[i]:
            print(j, end=" ")
        print()

  def showList(self):
    return self.adj

## Queue class
class Queue:
  def __init__(self):
    self.queue = []

  def addQueue(self,v):
    self.queue.append(v)

  def deque(self):
    v = None
    if not self.isEmpty():
      v = self.queue[0]
      self.queue = self.queue[1:]

    return v

  def isEmpty(self):
   return (self.queue == [])

  def __str__(self):
    return(str(self.queue))

## Stack implementation
class Stack:
  def __init__(self):
    self.stack = []

  def push(self,v):
      self.stack.append(v)

  def pop(self):
    v = None
    if not self.isempty():
      v = self.stack[-1]
      self.stack = self.stack[:len(self.stack)-1]

    return v

  def isempty(self):
    return (self.stack ==[])

  def __str__(self):
    return (str(self.stack))

s = Stack()
s.push(2)
s.push(3)
s.push(4)
s.push(5)
s.pop()
print(s)

l = Queue()
l.addQueue(2)
l.addQueue(3)
print(l.deque())
print(l)

adj = [[] for _ in range(5)]
adjcencyList = AdjecencyList(adj)
adjcencyList.addEdge(2,3)
adjcencyList.addEdge(2,4)
adjcencyList.addEdge(0,2)
adjcencyList.addEdge(1,3)
adjcencyList.displayList()
print(adj)

## BFS of graphn using adjecency list
def bfs(adjList,root):
  (level,parent) = ({},{})
  my_set = list()
  ## make all level and parent as -1 means unvisited
  for i in range(len(adjList)):
    level[i] = -1
    parent[i] = -1
  q = Queue()
  level[root] = 0
  q.addQueue(root) ## 1st add the root in the queue
  while (not q.isEmpty()):
    s = q.deque()
    my_set.append(s)
    for rec in adjList[s]:
      if (level[rec] == -1):
        level[rec] = level[s] + 1
        parent[rec] = s
        q.addQueue(rec)
  return level,parent,my_set

bfs(adj,2),adj

## adjecency list using dist
class adjListDist:
  def __init__(self,adj=None):
    self.adj = adj

  def addEdge(self,i,j):
    if i in self.adj:
      self.adj[i].append(j)
    else:
      self.adj[i] = [j]

    if j in self.adj:
      self.adj[j].append(i)
    else:
      self.adj[j] = [i]

  def displayList(self):
    for i in self.adj:
        print(f"{i}: ", end="")
        for j in self.adj[i]:
            print(j, end=" ")
        print()

  def showList(self):
    return self.adj

## BFS of graphn using adjecency list implementation of the dict insted of the nested list
def bfsDict(root,adjList={}):
  (level,parent) = ({},{})
  my_set = list()
  ## make all level and parent as -1 means unvisited
  for i in (adjList.keys()):
    level[i] = -1
    parent[i] = -1
  q = Queue()
  level[root] = 0
  q.addQueue(root) ## 1st add the root in the queue
  while (not q.isEmpty()):
    s = q.deque()
    my_set.append(s)
    for rec in adjList[s]:
      if (level[rec] == -1):
        level[rec] = level[s] + 1
        parent[rec] = s
        q.addQueue(rec)
  return level,parent,my_set

dist = {}
adjcencyList = adjListDist(dist)
adjcencyList.addEdge(2,3)
adjcencyList.addEdge(2,4)
adjcencyList.addEdge(1,2)
adjcencyList.addEdge(1,3)
adjcencyList.displayList()
adjcencyList.displayList()
dist

bfsDict(2,dist)

#### End note in adjecency list isted of the nested list like this [[],[]] dict is more efficient cause if we have graph member 11,12 ,30 then we cant use nested list
### then we use dict {key:[]} this is very ise ful

## DFS for adjecency list using dist

"""#Trees"""

#implementation of simple tree
class TreeNode:
    def __init__(self, data):
        self.data = data
        self.children = []

    def addEdge(self,x,y,adj):
      adj[x].append(y)
      adj[y].append(x)

    def printParents(self,node, adj, parent):
      # current node is Root, thus, has no parent
      if parent == 0:
          print("{}->Root".format(node))
      else:
          print("{}->{}".format(node, parent))

      # Using DFS
      for cur in adj[node]:
          if cur != parent:
              self.printParents(cur, adj, node)

    # Function to print the children of each node
    def printChildren(Root, adj):
        # Queue for the BFS
        q = deque()
        # pushing the root
        q.append(Root)
        # visit array to keep track of nodes that have been
        # visited
        vis = [0] * len(adj)
        # BFS
        while q:
            node = q.popleft()
            vis[node] = 1
            print("{}->".format(node)),
            for cur in adj[node]:
                if vis[cur] == 0:
                    print(cur),
                    q.append(cur)
            print()

N = 7
Root = 1
# Adjacency list to store the tree
adj = [[] for _ in range(N + 1)]
node = TreeNode(1)
node.addEdge(1,2,adj)
node.addEdge(1, 3, adj)
node.addEdge(1, 4, adj)
node.addEdge(2, 5, adj)
node.addEdge(2, 6, adj)
node.addEdge(4, 7, adj)
#print("The parents of each node are:")
#node.printParents(Root, adj, 0)

print(adj)

## implementation of the tree (Binary Tree)
class Node:
  def __init__(self,val):
    self.right = None
    self.left = None
    self.val = val

# Initialize and allocate memory for tree nodes
firstNode = Node(2)
secondNode = Node(3)
thirdNode = Node(4)
fourthNode = Node(5)


thirdNode.left = firstNode
thirdNode.right = thirdNode
thirdNode.right = fourthNode

## BFS for ordinary tree
def bfs(root):
    if root is None:
      return
    queue = [root]
    while queue:
      node = queue.pop(0) ## pop the element
      print(node.val,end =" ")
      if node.left:
        queue.append(node.left)
      if node.right:
        queue.append(node.right)

bfs(root)

root = Node(3)
root.left = Node(2)
root.right = Node(4)
root.right.right = Node(5)

def pre_order_dfs(node):
    if node is None:
        return
    print(node.val, end=' ')
    (pre_order_dfs(node.left))
    (pre_order_dfs(node.right))

pre_order_dfs(root)

def post_Order_dfs(node):
  if node is None:
    return
  post_Order_dfs(node.left)
  post_Order_dfs(node.right)
  print(node.val,end=' ')

post_Order_dfs(root)

def in_Order(node):
  if node is None:
    return
  in_Order(node.left)
  print(node.val,end=" ")
  in_Order(node.right)

in_Order(root)