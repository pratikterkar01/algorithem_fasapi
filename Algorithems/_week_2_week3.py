# -*- coding: utf-8 -*-
"""_Week_2_week3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15a-JW-pxSVJAXpyGfkrIU3O-_vyaai0U

#Week 2 lec 4
## Binary search
"""

## take sorted list and then ,see middle element for comparison and is less than take left or right
## check if the number are repeated ?
def binarySearch(ipList,s):
  if ipList == []:
    return False
  middle_index = len(ipList)//2
  middle_element = ipList[middle_index]
  if middle_element == s:
    return middle_element,middle_index
  if s < middle_element:
    binarySearch(ipList[:middle_index],s)
  if s > middle_element:
    binarySearch(ipList[middle_index + 1:],s)

list1 = [1,2,3,4,4,5,6,7,8,9]
binarySearch(list1,5)

import time
import random
class ExceptionTimer(Exception):
  '''Custom error'''
class Timer:
  def __init__(self):
    self._start_time = None
    self._elapsed_time = None

  def start(self):
    if self._start_time is not None:
      raise Exception("Timer is running")
    self._start_time = time.perf_counter()

  def end(self):
    if self._start_time is None:
      raise ExceptionTimer("Timmer not start")
    self._elapsed_time = time.perf_counter() - self._start_time
    self._start_time = None


  def elapsed(self):
    if self._elapsed_time is None:
      raise ExceptionTimer("Timer have not been start yet, start timer")
    return self._elapsed_time

  def __str__(self):
    "print( the string)"
    return (str(self._elapsed_time))

"""# selection sort"""

# slect 1st elememt find the min from 2nd position to remaning list
def selectionSort(ip,ipIndex):
  if ipIndex == len(ip) - 1:
    return ipIndex
  temp_ele = 0
  ele_1 = ip[ipIndex]
  min_number_index = ipIndex+1
  for index in range(ipIndex,len(ip)):
    if ip[index] < ip[min_number_index]:
      min_number_index = index

  if  ip[min_number_index] < ele_1:
    temp_ele = ip[ipIndex]
    ip[ipIndex] = ip[min_number_index]
    ip[min_number_index] = temp_ele
  selectionSort(ip,ipIndex+1)

t = Timer()
t.start()
# Generate a list of 5 random integers between 1 and 100
random_integers = [random.randint(1, 100000) for _ in range(100)]
selectionSort(random_integers,0)
t.end()
print(random_integers)
print("Time required",t)

"""## Insertion sort"""

def insertionSort(ipList):
  temp_ele = 0
  for i in range(0,len(ipList)):
    swap_index = i
    while ipList[swap_index] < ipList[swap_index - 1] and swap_index > 0:
      # swap the number
      temp_ele = ipList[swap_index]
      ipList[swap_index] = ipList[swap_index - 1]
      ipList[swap_index -1] = temp_ele
      swap_index -= 1
  return ipList

arr = [random.randint(1, 10) for _ in range(5)]
t.start()
insertionSort(arr)
t.end()
print("time for insertion sort is ",t)
print(arr)

"""## Merge sort"""

def merge(ipList1,ipList2):
  a,b = len(ipList1),len(ipList2)
  c,i,j,k  = [],0,0,0
  while k < a+b:
    if i == a:
      c.extend(b[j:])
      k = k - (n-j)
    elif j == n:
      c.extend(a[i:])
      k = k - (n-i)
    elif a[i] < b[j]:
      c.append(a[i])
      i,k = i+1,k+1
    else:
      c.append(b[j])
      j,k = j+1,k+1


  return c

def mergeSort(ipList):
  if len(ipList) == 1:
    return ipList
  n = len(ipList)

  L = ipList[:n//2]
  r= ipList[n//2:]

  merge(L,r)

  return ipList

arr2 = [random.randint(1, 10) for _ in range(5)]
t.start()
insertionSort(arr2)
t.end()
print("time for insertion sort is ",t)
print(arr)

"""## quick sort"""

def QuickSort(rawList, strIndex, endIndex, message=""):
    #print("Inside QuickSort method")
    #print(f"QuickSort method Input: {rawList}, {message}")

    if strIndex < endIndex:
        pivotIndex =  Partition(rawList, strIndex, endIndex, message)
        #print(f"PivotIndex {pivotIndex}")

        leftMessage = f"Left part until index {pivotIndex - 1} and start on {strIndex} "
        rightMessage = f"Right part starting from index {pivotIndex + 1} nd end on {endIndex}"

        # ðŸ”¹ Run both recursive QuickSorts *concurrently*

        QuickSort(rawList, strIndex, pivotIndex - 1, leftMessage)

        QuickSort(rawList, pivotIndex + 1, endIndex, rightMessage)



    #print(f"sortedList {rawList}")

def Swap(iparray,strIndex,endIndex):
  if strIndex != endIndex and strIndex < endIndex:
    #print(f"In swap strIndex {strIndex}, endIndex {endIndex}")
    temp = iparray[strIndex]
    iparray[strIndex] = iparray[endIndex]
    iparray[endIndex] = temp

def Partition(ipList,strIndex,endIndex,message=""):
  #print(f"in Partition ipList {ipList}")
  pivotNumber  = ipList[strIndex]
  pivotIndex = strIndex
  strIndex += 1
  #print(f"Inside Partition {message} startindex : {strIndex} and endIndex : {endIndex}")

  while strIndex < endIndex :
    #print(f" 2 :Inside Partition with startindex : {strIndex} and endIndex : {endIndex}")

    while ipList[strIndex] <= pivotNumber and strIndex < len(ipList) -1:
      strIndex += 1
      #print(f"1 : startindex : {strIndex} and endIndex : {endIndex}")

    while ipList[endIndex] > pivotNumber and endIndex > 0:
      endIndex -= 1
      #print(f"2 :  startindex : {strIndex} and endIndex : {endIndex}")

    if strIndex < endIndex :
      Swap(ipList,strIndex,endIndex)
    #print(ipList)

  if strIndex == endIndex:
    while ipList[endIndex] > pivotNumber:
      endIndex -= 1

  if pivotIndex != endIndex :
   # print(f"pivot Index is {pivotIndex}")
    Swap(ipList,pivotIndex,endIndex)

  #print(f"ipLiat {ipList}")
  return endIndex

arr3 = [-3,-2,-2,-3,0,2,5,6,7,4,7,]
t.start()
QuickSort(arr3,0,len(arr3)-1,"Intiatsort")
t.end()
print("time for insertion sort is ",t)
print(arr3)

"""## week 3 lec 6 linked list"""

class Node:
  def __init__(self,v=None):
    self.value = v
    self.next = None

  def isEmpty(self):
    if self.value == None:
      return True
    else:
      return False

  def append(self,v):
    if self.isEmpty():
      self.value = v
    elif self.next == None:
      self.next = Node(v)
    else:
      self.next.append(v)

    return

  def insert(self,v):
    if self.isEmpty():
      self.value = v
      return
    new_node = Node(v)

    (self.value,new_node.value) = new_node.value,self.value
    (self.next,new_node.next) = new_node,self.next

n = Node()
n.append(10)
n.append(20)
n.append(30)

op = [i for i in n]
op